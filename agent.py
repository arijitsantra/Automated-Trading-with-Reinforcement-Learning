import random
import math
import pandas as pd
from matplotlib import pyplot as plt

class Trading_Agent(object):
    valid_actions = ['buy','sell','hold']

    def __init__(self, learning, epsilon, alpha, values, states, Q, i, start_date):

        # Set parameters of the learning agent
        self.learning = learning # Whether the agent is expected to learn
        self.Q = Q          # Create a Q-table which will be a dictionary of tuples
        self.epsilon = epsilon   # Random exploration factor
        self.alpha = alpha       # Learning factor
        self.values = values
        self.states = states
        self.start_date = start_date
        self.asset_value=[(self.start_date, 50, 50*self.values[0][1],0,50*self.values[0][1], 50*self.values[0][1]),]
        self.i=i

    def build_state(self):
        """ The build_state function is called when the agent requests data about the state"""

        # Set 'state' as a tuple of relevant data for the agent 
        state = states[self.i]
        return state


    def get_maxQ(self, state):
        """ The get_maxQ function is called when the agent is asked to find the
            maximum Q-value of all actions based on the 'state'. """

      
        # Calculate the maximum Q-value of all actions for a given state

        maxQ = max(self.Q[state].values())
        max_actions = []
        for key, value in self.Q[state].iteritems():
            if maxQ == value:
                max_actions.append(key)
        return maxQ, max_actions 


    def createQ(self, state):
        """ The createQ function is called when a state is generated by the agent. """


        # When learning, check if the 'state' is not in the Q-table
        # If it is not, create a new dictionary for that state
        #   Then, for each action available, set the initial Q-value to 0.0
        if self.learning == True:
            if not state in self.Q:
                self.Q[state]=self.Q.get(state,{'buy':0.0, 'sell':0.0, 'hold':0.0})

        return


    def choose_action(self, state):
        """ The choose_action function is called when the agent is asked to choose
            which action to take, based on the 'state'. """

        self.state = state
        action = None
        # When learning, choose a random action with 'epsilon' probability
        # Otherwise, choose an action with the highest Q-value for the current state
        if self.learning == False:
            action = random.choice(self.valid_actions)
        elif random.random() < self.epsilon:
            action = random.choice(self.valid_actions)
        else:
            maxQ, max_actions = self.get_maxQ(state)
            action=random.choice(max_actions)
        return action


    def learn(self, state, action, reward):
        """ The learn function is called after the agent completes an action and
            receives a reward. """

        if self.learning == True:
            self.Q[state][action] = reward * self.alpha + self.Q[state][action]*(1-self.alpha)
        return


    def update(self):
        """ The update function is called for each closing price. This function will build the agent
            state, choose an action, receive a reward, and learn if enabled. """
        if self.learning == True:
            datarange = 247
        else: datarange = 123
        for self.i in range(datarange):
            state = self.build_state()          # Get current state
            self.createQ(state)                 # Create 'state' in Q-table
            action = self.choose_action(state)  # Choose an action
            reward = self.asset(action) # Receive a reward
            self.learn(state, action, reward) # Q-learn
            if self.learning == False:
                list.append(self.values[self.i][1]*50)
        if self.learning == False:
                print(self.asset_value)
                list1, list2, list3, list4, list5, list6 = zip(*self.asset_value)
                plt.xlabel("Date") 
                plt.ylabel("Asset Value in INR")
                plt.plot(list1, list5, color='green')
                plt.plot(list1, list6, color='blue')
                plt.show()
        
        return
        
    def asset(self, action):
        if action == 'buy':
            new_asset_value = (self.values[self.i+1][0], self.asset_value[self.i][1]+1, (self.asset_value[self.i][1]+1)*self.values[self.i+1][1], (self.asset_value[self.i][3]-self.values[self.i+1][1])*1.00011685, (self.asset_value[self.i][1]+1)*self.values[self.i+1][1]+(self.asset_value[self.i][3]-self.values[self.i+1][1])*1.00011685, 50*self.values[self.i+1][1])
            self.asset_value.append(new_asset_value)
        elif action == 'sell':
            new_asset_value = (self.values[self.i+1][0], self.asset_value[self.i][1]-1,(self.asset_value[self.i][1]-1)*self.values[self.i+1][1], (self.asset_value[self.i][3]+self.values[self.i+1][1])*1.00011685, (self.asset_value[self.i][1]-1)*self.values[self.i+1][1]+(self.asset_value[self.i][3]+self.values[self.i+1][1])*1.00011685, 50*self.values[self.i+1][1])
            self.asset_value.append(new_asset_value)
        elif action == 'hold':
            new_asset_value = (self.values[self.i+1][0], self.asset_value[self.i][1],(self.asset_value[self.i][1])*self.values[self.i+1][1], (self.asset_value[self.i][3])*1.00011685, (self.asset_value[self.i][1])*self.values[self.i+1][1]+(self.asset_value[self.i][3])*1.00011685, 50*self.values[self.i+1][1])
            self.asset_value.append(new_asset_value)
        closing = self.asset_value[self.i+1][2]+self.asset_value[self.i+1][3]
        next_day_closing = self.asset_value[self.i][2]+self.asset_value[self.i][3]
        sharpe_ratio = (((closing/next_day_closing)-1)-0.00011685)/(self.values[self.i][2])
        return sharpe_ratio
        


values_df=pd.read_excel("values.xlsx")
states_df=pd.read_excel("states.xlsx")
values=[]
states=[]

for index, row in values_df.iterrows():
    data=(row["Date"],row["Nifty"],row["VIX"])
    values.append(data)
for index, row in states_df.iterrows():
    data=(row["5 day MA"],row["10 day MA"],row["20 day MA"],row["VIX"],row["RSI"],row["MACD"])
    states.append(data)
Q = dict()
epsilon = 1
alpha = 0.5
for trial in range(1,150):
    # epsilon = alpha ** trial
    # epsilon = 1.0/(trial**2)
    # epsilon = 1.0/(trial**2 + alpha*trial)
    # epsilon = 1.0/(trial**2 - alpha*trial)
    epsilon = math.fabs(math.cos(alpha*trial))
    # epsilon = math.fabs(math.cos(alpha*trial))/(trial**2)
    agent=Trading_Agent(True, epsilon, alpha, values, states, Q, 0, values[0][0])
    agent.update()
test_values_df=pd.read_excel("test_values.xlsx")
test_states_df=pd.read_excel("test_states.xlsx")
test_values=[]
test_states=[]
for index, row in test_values_df.iterrows():
    data=(row["Date"],row["Nifty"],row["VIX"])
    test_values.append(data)
for index, row in test_states_df.iterrows():
    data=(row["5 day MA"],row["10 day MA"],row["20 day MA"],row["VIX"],row["RSI"],row["MACD"])
    test_states.append(data)
agent=Trading_Agent(False, 0, 0, test_values, test_states, Q, 0, test_values[0][0])
agent.update()